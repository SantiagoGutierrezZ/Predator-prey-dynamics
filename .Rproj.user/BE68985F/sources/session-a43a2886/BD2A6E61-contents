library(dplyr)
library(purrr)
rm(list = ls())


all_data <- read.csv("dataActivityPatterns.csv", header = TRUE)

spA <- "Lynx pardinus"
spB <- "Lepus granatensis"

detections <- all_data %>%
  # Agrupar por sitio
  group_by(site) %>%
  # Contar la presencia de cada especie en cada sitio
  summarise(
    spA_present = any(sp == spA),
    spB_present = any(sp == spB),
    .groups = "drop"
  ) %>%
  # Filtrar los sitios donde ambas especies están presentes
  filter(spA_present & spB_present)

# Definir el sitio que se va a analizar
loc <- as.vector(detections$site)

# Leer el archivo CSV que contiene los datos de operación de los sitios
operation_tb <- read.csv("problemsCamtraps.csv")


# Crear un nombre dinámico basado en spA y spB
list_name <- paste0("data_", 
                    tolower(substr(gsub(" ", "", spA), 1, 3)), "_", 
                    tolower(substr(gsub(" ", "", spB), 1, 3)))

# Crear la lista y asignarla con el nombre dinámico
assign(list_name, list())

for (current_loc in loc) {
  
  operation_tb_filtered <- operation_tb %>%
    filter(station == current_loc) %>%
    select_if(~ any(!is.na(.) & . != "")) %>%
    mutate(across(2:ncol(.), ~ as.POSIXct(., format = "%d/%m/%Y %H:%M")))
  
  loc_activity <- seq(from = operation_tb_filtered$setup_date[1], to = operation_tb_filtered$retrieval_date[1], by = "min")
  
  activity_tb <- data.frame(
    datetime = loc_activity,
    activity = 1
  )
  
  problem_from <- operation_tb_filtered[grep("^problem.*_from", names(operation_tb_filtered))]
  problem_to <- operation_tb_filtered[grep("^problem.*_to", names(operation_tb_filtered))]
  
  # Si no hay problemas, el sitio estuvo activo todo el período
  if (length(problem_from) == 0 || length(problem_to) == 0) {
    activity_tb$activity <- 1  # Todos los minutos están activos
  } else {
    # Crear una matriz lógica para marcar inactividad
    inactive_matrix <- matrix(FALSE, nrow = length(loc_activity), ncol = length(problem_from))
    
    # Llenar la matriz de inactividad con TRUE en los periodos correspondientes
    for (i in 1:length(problem_from)) {
      inactive_matrix[, i] <- loc_activity >= problem_from[[i]] & loc_activity <= problem_to[[i]]
    }
    
    # Actualizar la columna 'activity'
    activity_tb$activity <- ifelse(rowSums(inactive_matrix) > 0, 0, 1)
  }
  
  presence <- all_data %>%
    mutate(datetime = as.POSIXct(clock_date_time, format = "%Y-%m-%d %H:%M")) %>%
    filter(site %in% current_loc,
           sp %in% c(spA, spB)) %>%
    select(datetime, site, sp)
  
  tabla <- merge(activity_tb, presence, by = "datetime", all.x = TRUE)
  
  listino <- vector("list", 1)
  
  for (i in 1:1) {
    tabla <- tabla %>%
      mutate(
        sp_A = case_when(
          sp == spA ~ 1,
          activity == 1 & is.na(sp) ~ 0,
          sp == spB ~ 0,
          TRUE ~ NA_real_
        ),
        sp_B = case_when(
          sp == spB ~ 1,
          activity == 1 & is.na(sp) ~ 0,
          sp == spA ~ 0,
          TRUE ~ NA_real_
        )
      ) %>%
      filter((sp_A == 1 | sp_B == 1) & !(sp_A == 1 & sp_B == 1) | is.na(sp_A) | is.na(sp_B)) %>%
      mutate(
        interval = case_when(
          sp_A == 1 & lead(sp_B) == 1 ~ "AB",
          sp_B == 1 & lead(sp_A) == 1 ~ "BA",
          TRUE ~ NA_character_
        ),
        time_diff = as.numeric(abs(difftime(datetime, lead(datetime), units = "mins")))
      ) %>%
      filter(!is.na(interval))
    
    listino[[i]] <- tabla
  }
  
  list_name[[current_loc]] <- listino
}

###############################################################################################
# 
#                                Simulation                                                   #
# 
###############################################################################################

simulation_lyn_lep <- list()

for (current_loc in loc) {
  
  operation_tb_filtered <- operation_tb %>%
    filter(station == current_loc) %>%
    select_if(~ any(!is.na(.) & . != "")) %>%
    mutate(across(2:ncol(.), ~ as.POSIXct(., format = "%d/%m/%Y %H:%M")))

  loc_activity <- seq(from = operation_tb_filtered$setup_date[1], to = operation_tb_filtered$retrieval_date[1], by = "min")
  
  activity_tb <- data.frame(
    datetime = loc_activity,
    activity = 1
  )
  
  problem_from <- operation_tb_filtered[grep("^problem.*_from", names(operation_tb_filtered))]
  problem_to <- operation_tb_filtered[grep("^problem.*_to", names(operation_tb_filtered))]
  
  # Si no hay problemas, el sitio estuvo activo todo el período
  if (length(problem_from) == 0 || length(problem_to) == 0) {
    activity_tb$activity <- 1  # Todos los minutos están activos
  } else {
    # Crear una matriz lógica para marcar inactividad
    inactive_matrix <- matrix(FALSE, nrow = length(loc_activity), ncol = length(problem_from))
    
    # Llenar la matriz de inactividad con TRUE en los periodos correspondientes
    for (i in 1:length(problem_from)) {
      inactive_matrix[, i] <- loc_activity >= problem_from[[i]] & loc_activity <= problem_to[[i]]
    }
    
    # Actualizar la columna 'activity'
    activity_tb$activity <- ifelse(rowSums(inactive_matrix) > 0, 0, 1)
  }
  
  
  size <- nrow(activity_tb)
  mins <- nrow(activity_tb[activity_tb$activity == 1, ])
  
  d.spA <- as.numeric(nrow(all_data[all_data$sp == spA & all_data$site == current_loc, ]) / mins)
  d.spB <- as.numeric(nrow(all_data[all_data$sp == spB & all_data$site == current_loc, ]) / mins)
  
  rep <- 100
  listino <- vector("list", rep)
  
  for (i in 1:rep) {
    presence_spA <- rbinom(size, 1, d.spA)
    presence_spB <- rbinom(size, 1, d.spB)
    
    tabla <- activity_tb %>%
      mutate(
        spA = presence_spA,
        spB = presence_spB,
        spA = ifelse(activity == 1, spA, NA),
        spB = ifelse(activity == 1, spB, NA)
      ) %>%
      filter((spA == 1 | spB == 1) & !(spA == 1 & spB == 1) | is.na(spA) | is.na(spB)) %>%
      mutate(
        interval = case_when(
          spA == 1 & lead(spB) == 1 ~ "AB",
          spB == 1 & lead(spA) == 1 ~ "BA",
          TRUE ~ NA_character_
        ),
        time_diff = as.numeric(abs(difftime(datetime, lead(datetime), units = "mins")))
      ) %>%
      filter(!is.na(interval))
    
    listino[[i]] <- tabla
  }
  
  simulation_lyn_lep[[current_loc]] <- listino
}


################################################################################################
# 
#                                Comparison                                                   #
# 
################################################################################################

# real_data_bad <- matrix(FALSE, nrow = length(data_bad_rab), ncol = length(data_bad_rab[[1]]))
# real_data_vul <- matrix(FALSE, nrow = length(data_vul_rab), ncol = length(data_vul_rab[[1]]))
# real_data_gen <- matrix(FALSE, nrow = length(data_gen_rab), ncol = length(data_gen_rab[[1]]))
# real_data_her <- matrix(FALSE, nrow = length(data_her_rab), ncol = length(data_her_rab[[1]]))
# real_data_lyn <- matrix(FALSE, nrow = length(data_lyn_rab), ncol = length(data_lyn_rab[[1]]))
# 
# 
# # Llenar la matriz
# for (i in seq_along(data_lyn_rab)) {
#   for (j in seq_along(data_lyn_rab[[i]])) {
#     dataframe <- data_lyn_rab[[i]][[j]]
#     
#     # Verificar si el dataframe está vacío
#     if (nrow(dataframe) == 0) {
#       real_data_lyn[i, j] <- NA  # Mantener como lógico
#     } else {
#       # Calcular la media de time_diff
#       real_data_lyn[i, j] <- mean(dataframe$time_diff, na.rm = TRUE)
#     }
#   }
# }
# 
# spA <- "Herpestes ichneumon"
# 
# excluded_sites <- all_data %>%
#   # Filter the dataset to include only records of Predator and rabbit
#   filter(sp %in% c(spA, spB)) %>%
#   # Arrange the dataset by site and time of detection in ascending order
#   arrange(site, clock_date_time) %>%
#   # Group the data by site to process interactions within each location independently
#   group_by(site) %>%
#   # Create new columns:
#   mutate(
#     # Define interaction intervals based on consecutive species detections
#     interval = case_when(
#       sp == spA & lead(sp) == spB ~ "AB",
#       sp == spB & lead(sp) == spA ~ "BA",
#       sp == spA & lead(sp) == spA ~ "AA",
#       sp == spB & lead(sp) == spB ~ "BB",
#       TRUE ~ NA_character_
#     ),
#     # Calculate the time difference (in minutes) between consecutive detections
#     time_diff = abs(difftime(clock_date_time, lead(clock_date_time), units = "mins"))
#   ) %>%
#   # Filter the dataset to keep only interactions where a fox and a rabbit are involved
#   filter(interval %in% c("AB", "BA"#, "BB", "AA", NA
#                          ),
#          site == "6") %>%
#   # Select only the relevant columns for the final dataset
#   select(site, clock_date_time, sp, interval, time_diff)
# 
# 
# problems_tb <- operation_tb %>%
#   filter(station == "6") %>%
#   select_if(~ any(!is.na(.) & . != "")) %>%
#   mutate(across(2:ncol(.), ~ as.POSIXct(., format = "%d/%m/%Y %H:%M")))
# 
# p_from <- problems_tb[grep("^problem.*_from", names(problems_tb))]
# p_from <- p_from[, p_from > excluded_sites$clock_date_time]
# p_from <- p_from[,1]
# 
# difference <- abs(difftime(excluded_sites$clock_date_time, p_from, units = "mins"))
# 
# m_difference <- mean(c(as.numeric(difference), as.numeric(excluded_sites$time_diff)))
# 
# # Verificar si el único valor de la matriz es NA
# # if (is.na(real_data[1, 1])) {
# #   real_data[1, 1] <- m_difference
# # }
# 
# real_data_her[12,1] <- m_difference


##################################################################################################
# # Obtenemos el número de sitios y el número de repeticiones
# simulated_data_bad <- matrix(FALSE, length(simulation_bad_rab), ncol = rep)
# simulated_data_vul <- matrix(FALSE, length(simulation_vul_rab), ncol = rep)
# simulated_data_gen <- matrix(FALSE, length(simulation_gen_rab), ncol = rep)
# simulated_data_her <- matrix(FALSE, length(simulation_her_rab), ncol = rep)
# simulated_data_lyn <- matrix(FALSE, length(simulation_lyn_rab), ncol = rep)
# 
# 
# # Llenar la matriz
# for (i in seq_along(simulation_lyn_rab)) {
#   for (j in seq_along(simulation_lyn_rab[[i]])) {
#     dataframe <- simulation_lyn_rab[[i]][[j]]
#     
#     # Verificar si el dataframe está vacío
#     if (nrow(dataframe) == 0) {
#       simulated_data_lyn[i, j] <- NA  # Mantener como lógico
#     } else {
#       # Calcular la media de time_diff
#       simulated_data_lyn[i, j] <- mean(dataframe$time_diff, na.rm = TRUE)
#     }
#   }
# }

##################################################################################################

# # Inicializar la matriz comparation
# comparison_bad_rab <- matrix(FALSE, nrow = nrow(real_data_bad), ncol = rep)
# comparison_vul_rab <- matrix(FALSE, nrow = nrow(real_data_vul), ncol = rep)
# comparison_gen_rab <- matrix(FALSE, nrow = nrow(real_data_gen), ncol = rep)
# comparison_her_rab <- matrix(FALSE, nrow = nrow(real_data_her), ncol = rep)
# comparison_lyn_rab <- matrix(FALSE, nrow = nrow(real_data_lyn), ncol = rep)
# 
# 
# # Comparar fila por fila
# for (i in 1:nrow(real_data_lyn)) {
#   comparison_lyn_rab[i, ] <- real_data_lyn[i, ] > simulated_data_lyn[i, ]
#   comparison_lyn_rab[is.na(comparison_lyn_rab)] <- FALSE
#   }
# 
# # Calcular proporción de TRUE
# n_total <- nrow(comparison_lyn_rab) * ncol(comparison_lyn_rab)
# n_true <- sum(comparison_lyn_rab)
# 
# # Calcular intervalo de confianza y prueba de hipótesis
# ic_result <- prop.test(n_true, n_total)
# 
# # Resultados
# ic_result$estimate  # Proporción estimada
# ic_result$conf.int  # Intervalo de confianza
# ic_result$p.value   # p-valor
# 
# Crear un dataframe inicial con los resultados
# results_meles <- data.frame(
#   sp = "Meles meles",
#   proportion = ic_result$estimate,
#   lower_CI = ic_result$conf.int[1],
#   upper_CI = ic_result$conf.int[2],
#   p_value = ic_result$p.value
# )
# 
# results_vulpes <- data.frame(
#   sp = "Vulpes vulpes",
#   proportion = ic_result$estimate,
#   lower_CI = ic_result$conf.int[1],
#   upper_CI = ic_result$conf.int[2],
#   p_value = ic_result$p.value
# )

# results_genetta <- data.frame(
#   sp = "Genetta genetta",
#   proportion = ic_result$estimate,
#   lower_CI = ic_result$conf.int[1],
#   upper_CI = ic_result$conf.int[2],
#   p_value = ic_result$p.value
# )

# results_herpestes <- data.frame(
#   sp = "Herpestes ichneumon",
#   proportion = ic_result$estimate,
#   lower_CI = ic_result$conf.int[1],
#   upper_CI = ic_result$conf.int[2],
#   p_value = ic_result$p.value
# )

# results_lynx <- data.frame(
#   sp = "Lynx pardinus",
#   proportion = ic_result$estimate,
#   lower_CI = ic_result$conf.int[1],
#   upper_CI = ic_result$conf.int[2],
#   p_value = ic_result$p.value
# )

# Agregar la nueva fila al dataframe
results_all <- rbind(results_meles, results_vulpes, results_genetta, results_herpestes, results_lynx)


#########################################################################################################
################################################################################################
# 
#                                Comparison Lepus granatensis                                  #
# 
################################################################################################

# real_data_mel_l <- matrix(FALSE, nrow = length(data_mel_lep), ncol = length(data_mel_lep[[1]]))
# real_data_vul_l <- matrix(FALSE, nrow = length(data_vul_lep), ncol = length(data_vul_lep[[1]]))
# real_data_gen_l <- matrix(FALSE, nrow = length(data_gen_lep), ncol = length(data_gen_lep[[1]]))
# real_data_her_l <- matrix(FALSE, nrow = length(data_her_lep), ncol = length(data_her_lep[[1]]))
# real_data_lyn_l <- matrix(FALSE, nrow = length(data_lyn_lep), ncol = length(data_lyn_lep[[1]]))
# 
# 
# # Llenar la matriz
# for (i in seq_along(data_lyn_lep)) {
#   for (j in seq_along(data_lyn_lep[[i]])) {
#     dataframe <- data_lyn_lep[[i]][[j]]
#     
#     # Verificar si el dataframe está vacío
#     if (nrow(dataframe) == 0) {
#       real_data_lyn_l[i, j] <- NA  # Mantener como lógico
#     } else {
#       # Calcular la media de time_diff
#       real_data_lyn_l[i, j] <- mean(dataframe$time_diff, na.rm = TRUE)
#     }
#   }
# }
# 
# spA <- "Vulpes vulpes"
# 
# excluded_sites <- all_data %>%
#   # Filter the dataset to include only records of Predator and rabbit
#   filter(sp %in% c(spA, spB)) %>%
#   # Arrange the dataset by site and time of detection in ascending order
#   arrange(site, clock_date_time) %>%
#   # Group the data by site to process interactions within each location independently
#   group_by(site) %>%
#   # Create new columns:
#   mutate(
#     # Define interaction intervals based on consecutive species detections
#     interval = case_when(
#       sp == spA & lead(sp) == spB ~ "AB",
#       sp == spB & lead(sp) == spA ~ "BA",
#       sp == spA & lead(sp) == spA ~ "AA",
#       sp == spB & lead(sp) == spB ~ "BB",
#       TRUE ~ NA_character_
#     ),
#     # Calculate the time difference (in minutes) between consecutive detections
#     time_diff = abs(difftime(clock_date_time, lead(clock_date_time), units = "mins"))
#   ) %>%
#   # Filter the dataset to keep only interactions where a fox and a rabbit are involved
#   filter(interval %in% c("AB", "BA"#, "BB", "AA", NA
#                          ),
#          site == "21B") %>%
#   # Select only the relevant columns for the final dataset
#   select(site, clock_date_time, sp, interval, time_diff)
# 
# 
# problems_tb <- operation_tb %>%
#   filter(station == "21B") %>%
#   select_if(~ any(!is.na(.) & . != "")) %>%
#   mutate(across(2:ncol(.), ~ as.POSIXct(., format = "%d/%m/%Y %H:%M")))
# 
# p_from <- problems_tb[grep("^problem.*_from", names(problems_tb))]
# p_from <- p_from[, p_from > excluded_sites$clock_date_time]
# p_from <- p_from[,1]
# 
# difference <- abs(difftime(excluded_sites$clock_date_time, p_from, units = "mins"))
# 
# m_difference <- mean(c(as.numeric(difference), as.numeric(excluded_sites$time_diff)))
# 
# # Verificar si el único valor de la matriz es NA
# # if (is.na(real_data[1, 1])) {
# #   real_data[1, 1] <- m_difference
# # }
# 
# real_data_vul_l[7,1] <- m_difference
# 

##################################################################################################
# Obtenemos el número de sitios y el número de repeticiones
# simulated_data_mel_l <- matrix(FALSE, length(simulation_mel_lep), ncol = rep)
# simulated_data_vul_l <- matrix(FALSE, length(simulation_vul_lep), ncol = rep)
# simulated_data_gen_l <- matrix(FALSE, length(simulation_gen_lep), ncol = rep)
# simulated_data_her_l <- matrix(FALSE, length(simulation_her_lep), ncol = rep)
# simulated_data_lyn_l <- matrix(FALSE, length(simulation_lyn_lep), ncol = rep)


# # Llenar la matriz
# for (i in seq_along(simulation_lyn_lep)) {
#   for (j in seq_along(simulation_lyn_lep[[i]])) {
#     dataframe <- simulation_lyn_lep[[i]][[j]]
#     
#     # Verificar si el dataframe está vacío
#     if (nrow(dataframe) == 0) {
#       simulated_data_lyn_l[i, j] <- NA  # Mantener como lógico
#     } else {
#       # Calcular la media de time_diff
#       simulated_data_lyn_l[i, j] <- mean(dataframe$time_diff, na.rm = TRUE)
#     }
#   }
# }

##################################################################################################

# Inicializar la matriz comparation
# comparison_mel_lep <- matrix(FALSE, nrow = nrow(real_data_mel_l), ncol = rep)
# comparison_vul_lep <- matrix(FALSE, nrow = nrow(real_data_vul_l), ncol = rep)
# comparison_gen_lep <- matrix(FALSE, nrow = nrow(real_data_gen_l), ncol = rep)
# comparison_her_lep <- matrix(FALSE, nrow = nrow(real_data_her_l), ncol = rep)
comparison_lyn_lep <- matrix(FALSE, nrow = nrow(real_data_lyn_l), ncol = rep)


# Comparar fila por fila
for (i in 1:nrow(real_data_lyn_l)) {
  comparison_lyn_lep[i, ] <- real_data_lyn_l[i, ] > simulated_data_lyn_l[i, ]
  comparison_lyn_lep[is.na(comparison_lyn_lep)] <- FALSE
}

# Calcular proporción de TRUE
n_total <- nrow(comparison_lyn_lep) * ncol(comparison_lyn_lep)
n_true <- sum(comparison_lyn_lep)

# Calcular intervalo de confianza y prueba de hipótesis
ic_result <- prop.test(n_true, n_total)

# Resultados
ic_result$estimate  # Proporción estimada
ic_result$conf.int  # Intervalo de confianza
ic_result$p.value   # p-valor
# 
# Crear un dataframe inicial con los resultados
# results_meles_l <- data.frame(
#   sp = "Meles meles",
#   proportion = ic_result$estimate,
#   lower_CI = ic_result$conf.int[1],
#   upper_CI = ic_result$conf.int[2],
#   p_value = ic_result$p.value
# )

# results_vulpes_l <- data.frame(
#   sp = "Vulpes vulpes",
#   proportion = ic_result$estimate,
#   lower_CI = ic_result$conf.int[1],
#   upper_CI = ic_result$conf.int[2],
#   p_value = ic_result$p.value
# )

# results_genetta_l <- data.frame(
#   sp = "Genetta genetta",
#   proportion = ic_result$estimate,
#   lower_CI = ic_result$conf.int[1],
#   upper_CI = ic_result$conf.int[2],
#   p_value = ic_result$p.value
# )

# results_herpestes_l <- data.frame(
#   sp = "Herpestes ichneumon",
#   proportion = ic_result$estimate,
#   lower_CI = ic_result$conf.int[1],
#   upper_CI = ic_result$conf.int[2],
#   p_value = ic_result$p.value
# )

# results_lynx_l <- data.frame(
#   sp = "Lynx pardinus",
#   proportion = ic_result$estimate,
#   lower_CI = ic_result$conf.int[1],
#   upper_CI = ic_result$conf.int[2],
#   p_value = ic_result$p.value
# )

# Agregar la nueva fila al dataframe
results_all_l <- rbind(results_meles_l, results_vulpes_l, results_genetta_l, results_herpestes_l, results_lynx_l)



results_rabbit <- results_all
results_hare <- results_all_l












